// TaskMaster 1.5 - Fresh Prisma Schema
// Based on the technical architecture documentation

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Task model - Core entity for task management
model Task {
  id              String    @id @default(cuid())
  title           String
  description     String?
  completed       Boolean   @default(false)
  priority        String    @default("MEDIUM")
  dueDate         DateTime?
  startDate       DateTime?
  estimatedHours  Int?
  parentId        String?
  groupId         String?   // Optional group assignment
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Self-referential relationship for subtasks
  parent          Task?     @relation("TaskHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  subtasks        Task[]    @relation("TaskHierarchy")
  
  // Group relationship
  group           TaskGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull)
  
  // Many-to-many relationship with tags
  tags            TaskTag[]
  
  // Conflict relationships
  conflicts       DateConflict[] @relation("TaskConflicts")
  conflictingWith DateConflict[] @relation("ConflictingTasks")
  
  // Activity logging
  activities      ActivityLog[]
  
  @@map("tasks")
}

// TaskGroup model - For grouping tasks
model TaskGroup {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  color       String   @default("#6366F1")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationship with tasks
  tasks       Task[]
  
  @@map("task_groups")
}

// Tag model - For categorizing tasks
model Tag {
  id        String    @id @default(cuid())
  name      String    @unique
  color     String    @default("#3B82F6")
  createdAt DateTime  @default(now())
  
  // Many-to-many relationship with tasks
  tasks     TaskTag[]
  
  @@map("tags")
}

// Junction table for Task-Tag many-to-many relationship
model TaskTag {
  taskId String
  tagId  String
  
  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  tag    Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@id([taskId, tagId])
  @@map("task_tags")
}

// Date conflict detection model
model DateConflict {
  id                 String          @id @default(cuid())
  taskId             String
  conflictingTaskId  String
  type               String
  severity           String          @default("MEDIUM")
  message            String
  createdAt          DateTime        @default(now())
  
  // Relationships to tasks
  task               Task            @relation("TaskConflicts", fields: [taskId], references: [id], onDelete: Cascade)
  conflictingTask    Task            @relation("ConflictingTasks", fields: [conflictingTaskId], references: [id], onDelete: Cascade)
  
  @@map("date_conflicts")
}

// Activity logging model for tracking changes and comments
model ActivityLog {
  id        String   @id @default(cuid())
  taskId    String
  action    String   // 'created', 'updated', 'completed', 'comment', 'subtask_added', 'subtask_updated', etc.
  details   String?  // JSON string with change details
  comment   String?  // User comment (for manual entries)
  isUserComment Boolean @default(false) // Distinguishes user comments from system actions
  createdAt DateTime @default(now())
  
  // Relationship to task
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  
  @@map("activity_logs")
}

// Note: SQLite doesn't support enums, so we use String fields with validation in the application layer
// Priority: LOW, MEDIUM, HIGH, URGENT
// ConflictType: OVERLAP, OVERLOAD
// ConflictSeverity: LOW, MEDIUM, HIGH